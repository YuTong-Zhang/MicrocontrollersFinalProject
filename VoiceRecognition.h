// Voice Recognition header file for use with Sound to Light System
//
// Demo of voice recognition capabilties that allows you to control an LED to perform various tasks with your
// voice. To begin, say "Hey VR" into microphone connected to EasyVR shield. This will turn the VR shield on
// and begin its listening mode. VR signals this with three quick blinks.
// You may then use any built-in commands or switch to customized commands. 
//
// Features:
// Group 0 - Triggers the start of the VR shield: Hey VR
// Group 1 - Customized commands: 
//       ON: Turns LED on
//      OFF: Turns LED on
//    BLINK: LED will blink on and off a few times
//     RAGE: LED will blick on and off very quickly, setting the mood for a party.
//  2 claps: LED will mimic 2 claps with 2 blinks
//    CHANGE TO PRESETS: Changes to preset commands (Wordset 3)
// Wordset 3 - Preset commands: One through Ten
//      0-5: Varying intensity of LED
//        6: Lights up for 5 seconds and then turns off
//        8: Puts it to sleep and then will wake up to 3 claps
//       10: Changes to customized commands (Group 1)
//
// This demo does not allow programming of voice control, only use of voice commands that have already been 
// programmed. Voice commands can be easily programmed for the VR shield using the easyVR commander which can 
// be downloaded. All the commands in group 0 and 1 were programmed by us using the easyVR commander.


#include "Arduino.h"
// Checking to ensure the right ports are configured and that the right IDE is being used
#if !defined(SERIAL_PORT_MONITOR)
  #error "Arduino version not supported. Please update your IDE to the latest version."
#endif

#if defined(SERIAL_PORT_USBVIRTUAL)
  // Shield Jumper on HW (for Leonardo and Due)
  #define port SERIAL_PORT_HARDWARE
  #define pcSerial SERIAL_PORT_USBVIRTUAL
#else
  // Shield Jumper on SW (using pins 12/13 or 8/9 as RX/TX)
  #include "SoftwareSerial.h"
  SoftwareSerial port(12, 13);
  #define pcSerial SERIAL_PORT_MONITOR
#endif

#include "EasyVR.h"

#pragma once   // Stops multiple opening of same .h files.

EasyVR easyvr(port);
/*
 * Creating a class for voice recognition with all of its variables and methods
 */
class VoiceRecognition{
  public:
    
    // Defining the values in each group and wordset we want to use
    enum Group
    {
      GROUP_0  = 0,
      GROUP_1 = 1,
    };
    
    enum Wordset
    {
      WORDSET_3 = 3,
    };
    enum Group0 
    {
      G0_HEY_VR = 0,
    };
    
    enum Group1
    {
      G0_CHANGE_TO_PRESETS = 0,
      G0_ON = 1,
      G0_OFF = 2,
      G0_BLINK = 3,
      G0_RAGE = 4,
      G0_TWO_CLAPS = 5,
    };
    
    
    enum Wordset3 
    {
      W1_Zero = 0,
      W1_One = 1,
      W1_Two = 2,
      W1_Three = 3,
      W1_Four = 4,
      W1_Five = 5,
      W1_Six = 6,
      W1_Seven = 7,
      W1_Eight = 8,
      W1_Nine = 9,
      W1_Ten = 10,
    };
    
    
    int8_t group, idx, mode;
    void setupForVR(); // Methods that belong in this class which includes setting up voice recognition and running and checking for audial inputs from the VR microphone, and performing different 
    void runVR();      // actions for certain commands
    void actionVR();
};  
  
/*
 * setupForVR() is responsible for setting up easyVR shield, making sure the serial port has begun, port configuerations set up, and that the easyVR has properly woken up and is responding
 */
void VoiceRecognition::setupForVR()
{
  // Configure which pins will be output pins
  pinMode(3,OUTPUT);
  analogWrite(3,0);
  // Setup PC serial port
  pcSerial.begin(9600);

  int mode = easyvr.bridgeRequested(pcSerial);
  // Checking to see which bridge mode it is in, and then running different cases for each mode
  // This code comes pre generated by the software for our easyVR shield and includes different options
  switch (mode)
  {
  case EasyVR::BRIDGE_NONE:      // This is the case statement used in our project
    // setup EasyVR serial port
    port.begin(9600);
    // run normally
    pcSerial.println(F("---"));
    pcSerial.println(F("Bridge not started!"));
    Serial.println("*** case EasyVR::BRIDGE_NONE: ***");
    break;
    
  case EasyVR::BRIDGE_NORMAL:
    // setup EasyVR serial port (low speed)
    port.begin(9600);
    // soft-connect the two serial ports (PC and EasyVR)
    easyvr.bridgeLoop(pcSerial);
    // resume normally if aborted
    pcSerial.println(F("---"));
    pcSerial.println(F("Bridge connection aborted!"));
     Serial.println("*** case EasyVR::BRIDGE_NORMAL: ***");
    break;
    
  case EasyVR::BRIDGE_BOOT:
    // setup EasyVR serial port (high speed)
    port.begin(115200);
    // soft-connect the two serial ports (PC and EasyVR)
    easyvr.bridgeLoop(pcSerial);
    // resume normally if aborted
    pcSerial.println(F("---"));
    pcSerial.println(F("Bridge connection aborted!"));
    Serial.println("*** case EasyVR::BRIDGE_BOOT: ***");
    break;
  
  } //end case.


  // Checking to see if easyVR has woken up and is responding correctly, and if not, let the user know
  while (!easyvr.detect())
  {
    Serial.println("EasyVR not detected!");
    delay(1000);
  } //end while

  // Once easyVR is responding correctly, we will set group number to the trigger group so it can listen for trigger words 
  easyvr.setPinOutput(EasyVR::IO1, LOW);
  Serial.println("EasyVR detected!");
  easyvr.setTimeout(5); // Set the number of seconds to listen for each command.
  easyvr.setLanguage(0); // Set language to English

  group = EasyVR::TRIGGER; //<-- start group (customize)
  Serial.println("Triggered");
 //easyvr.playSound(10, EasyVR::VOL_FULL); //Play woman asking asking question.
 Serial.println("Now exit setup...");

 
} //end setup.
  
/* 
 *  runVR() is able to detect for audial command, check to see if it matches the group of commands already stored, and then retrieve the corresponding numerical information and call actionVR()
 */
void VoiceRecognition::runVR()
{
  easyvr.setPinOutput(EasyVR::IO1, HIGH); // LED on (listening)
  
  Serial.print("Say a command in Group ");
  Serial.println(group);
  // Checking to see which group the commands are from so it can match the sound it recieves to the saved training, controlling the "recognition" portion
  if(group == 0){
    Serial.println("Recogizing command for group 0 ");
    easyvr.recognizeCommand(group); //Recognition of a built-in word.
  }
  else if(group == 3){
    Serial.println("Recogizing word for wordSet");
    easyvr.recognizeWord(group);
  }
  else if(group == 1){
    Serial.println("Recogizing command for group 1");
    easyvr.recognizeCommand(group);
  }

  while (!easyvr.hasFinished()); // Polls the status of on-going recogntion,training or asynchronous playback tasks.
  
  easyvr.setPinOutput(EasyVR::IO1, LOW); // LED off

  easyvr.setMicDistance(1);//Set mic operating distance. 1 nearest - 3 farthest.
  easyvr.setLevel(1);//Set strictness level for recognition of custom commands.
  easyvr.setKnob(0);//Set confidence threshold for recognition of built-in words.

  // Now that it has finished detecting, it will grab the values associated with each command
  if(group == 0){
    Serial.println("Getting command if there is one");
    idx = easyvr.getCommand();//Get the recognised command index if any.
  }
  else if(group==3){
    Serial.println("Getting word if there is one");
    idx = easyvr.getWord();
  }
  else if(group==1){
    Serial.println("Getting command if there is one");
    idx = easyvr.getCommand();
  }

  if (idx >= 0) // For when the easyVR successfully detects and interprets a command
  {
    uint8_t train = 0;
    char name[32];
    Serial.print("Command: ");
    Serial.print(idx);
   
    if (easyvr.dumpCommand(group, idx, name, train)) //Retrieves the name and training data of a custom command.
    //Group = 0-16 target group or values in #Groups.
    //idx = 0-31 index of the command within the selected group.
    //name = points to array of at least 32 characters that holds command label when function returns.
    
    {
      Serial.print(" = ");
      Serial.println(name);
    } //end if.
    else
    Serial.println();

    // Now that we have gathered the values and detected the sound input, we can call action to have some response to the input
    actionVR(); 

  } //end if.
 
  else // For when easyVR detects errors or timeout
  {
    if (easyvr.isTimeout())
      Serial.println("Timed out, try again...");
    int16_t err = easyvr.getError(); //Gets last error code. 0-255.
    if (err >= 0)
    {
      Serial.print("Error ");
      Serial.println(err, HEX);
      
    } //end if.

  } //end else.

} //end loop.

/*
 * actionVR() is able to respond to the values retrieved in runVR(). It has case structures that will switch to different actions for certain commands
 */
void VoiceRecognition::actionVR()
{
    Serial.println("Now in action function...");
    
    switch (group)
    {
    case GROUP_0:
      switch (idx)
      {
      case G0_HEY_VR:
        analogWrite(3,255); // Signals that the VR has been triggered
        delay(50);
        analogWrite(3,0);
        delay(50);
        analogWrite(3,255); 
        delay(50);
        analogWrite(3,0);
        delay(50);
        analogWrite(3,255); 
        delay(50);
        analogWrite(3,0);
        group = WORDSET_3; // Changing the group whenever this command is called from group 0 (where all the triggers are stored) to wordset 3 (where preset commands are stored)
        break;

      } //end case GROUP_0.
      break;

    case GROUP_1:
      switch (idx)
      {
      case G0_ON:
        analogWrite(3, 255); // When on is called, turn LED on high
        break;
        
      case G0_OFF:
        analogWrite(3, 0); // When off is called, turn LED on low
        break;
        
      case G0_CHANGE_TO_PRESETS:
        Serial.print("Setting group to be: ");
        Serial.println(WORDSET_3);
        group = WORDSET_3;  // Changing the group whenever this command is called from wordset 3 (where preset commands are stored) to group 0 (where all the triggers are stored)
        break;

      case G0_BLINK:
        Serial.print("Setting group to be: ");
        Serial.println(WORDSET_3);
        for(int i = 0; i < 5; i++){
          analogWrite(3,255); // When blink is called, LED is turned on and off
          delay(500);
          analogWrite(3,0);
          delay(500);
        }
        break;
        
      case G0_RAGE:
        Serial.print("Setting group to be: ");
        Serial.println(WORDSET_3);
        for(int i = 0; i < 19; i++){
          analogWrite(3,255); // When rage is called, LED is turned on and off rapidly
          delay(100);
          analogWrite(3,0);
          delay(100);
        }
        break;
        
      case G0_TWO_CLAPS:
        Serial.print("Setting group to be: ");
        Serial.println(WORDSET_3);
        analogWrite(3,255); // When there are two claps, the LED mimicks the sound and blinks twice
        delay(500);
        analogWrite(3,0);
        delay(500);
        analogWrite(3,255); 
        delay(500);
        analogWrite(3,0);
        break;
      }
    break;
      
    case WORDSET_3:
      switch (idx)
      {

      case W1_Ten:
        analogWrite(3,0);
         group = GROUP_1; // Changing the group whenever this command is called from wordset 3 (where preset commands are stored) to group 1 (where other customized commands are stored)
        break;
        
      case W1_Eight:
        mode = EasyVR::WAKE_ON_3CLAPS; // Waking the easy VR up with 3 claps
        Serial.println(mode);
        easyvr.sleep(mode); // Putting the easyVR to sleep when eight is called
        break;    
                      
      case W1_Six:
        Serial.println("On");
        analogWrite(3, 255);  // Turn LED on for a set time when six is called
        delay(5000);
        analogWrite(3,0);
        break;    
           
      case W1_Five:
        Serial.println("On");
        analogWrite(3, 255);  // Turn LED on to full brightness when five is called
        break;
        
      case W1_Four:
        Serial.println("On");
        analogWrite(3, 220);  // Dim LED a little when four is called
        break;
        
      case W1_Three:
        Serial.println("On");
        analogWrite(3, 175);  // Dim LED more when three is called
        break;
        
      case W1_Two:
        Serial.println("On");
       analogWrite(3, 130);  // Further dimming of LED when two is called
        break;
        
      case W1_One:
        Serial.println("On");
        analogWrite(3, 80);  // More dimming of LED when one is called
        break;
        
      case W1_Zero:
        Serial.println("Off");
        analogWrite(3,0);   // The dimmest case is when zero is called
        break;

      } //end idx case GROUP_1.

      break;
    
    } //end group case stmt.

} //end action.
